# 数值计算后端

<cite>
**本文档引用的文件**  
- [ArrayBackend](file://src/tyxonq/numerics/api.py#L18-L101)
- [set_backend](file://src/tyxonq/numerics/context.py#L17-L29)
- [NumpyBackend](file://src/tyxonq/numerics/backends/numpy_backend.py#L7-L162)
- [PyTorchBackend](file://src/tyxonq/numerics/backends/pytorch_backend.py#L12-L256)
- [CuPyNumericBackend](file://src/tyxonq/numerics/backends/cupynumeric_backend.py#L12-L252)
- [context.py](file://src/tyxonq/numerics/context.py)
</cite>

## 目录
1. [统一接口设计](#统一接口设计)
2. [后端实现与性能特征](#后端实现与性能特征)
3. [全局配置与上下文管理](#全局配置与上下文管理)
4. [后端选择与最佳实践](#后端选择与最佳实践)

## 统一接口设计

数值计算后端的核心是 `ArrayBackend` 协议，它定义了一个统一的数组/张量操作接口，确保了不同底层计算引擎之间的互操作性和代码可移植性。该协议采用最小化设计原则，仅包含核心的数组创建、基本算术运算和可选的向量化辅助功能。

`ArrayBackend` 接口要求实现以下核心功能：
- **数组创建与转换**：`array`, `asarray`, `to_numpy`
- **代数与数组操作**：`matmul`, `einsum`, `reshape`, `moveaxis`, `sum`, `mean`
- **基本数学函数**：`exp`, `sin`, `cos`, `sqrt`, `log`
- **线性代数**：`svd`
- **随机数生成**：`rng`, `normal`
- **自动微分桥接**（可选）：`requires_grad`, `detach`

此设计允许上层应用（如模拟器和研究内核）编写与后端无关的代码，只需通过接口调用所需功能，而无需关心底层是 NumPy、PyTorch 还是 CuPyNumeric。

**Section sources**
- [ArrayBackend](file://src/tyxonq/numerics/api.py#L18-L101)

## 后端实现与性能特征

### NumPy 后端

`NumpyBackend` 是基于 NumPy 的实现，提供了最广泛的兼容性和稳定性。它适用于 CPU 上的通用数值计算，特别适合小到中等规模的问题和原型开发。

- **性能特征**：纯 CPU 计算，性能依赖于 NumPy 的 BLAS 实现（如 OpenBLAS 或 MKL）。
- **内存使用**：标准的 CPU 内存使用模式，无特殊优化。
- **适用场景**：快速原型设计、小规模计算、对自动微分无需求的场景。

### PyTorch 后端

`PyTorchBackend` 利用 PyTorch 张量作为底层引擎，支持 GPU 加速和自动微分，是进行可微编程和大规模计算的理想选择。

- **性能特征**：支持 CPU 和 GPU 计算，`torch.compile` 可提供进一步的性能优化。
- **内存使用**：支持 GPU 内存，内存使用模式与 PyTorch 一致。
- **适用场景**：需要自动微分的变分量子算法（VQE）、梯度计算、大规模张量运算。

### CuPyNumeric 后端

`CuPyNumericBackend` 基于 CuPyNumeric，旨在提供 GPU/加速器上的高性能计算，同时保持与 NumPy API 的兼容性。

- **性能特征**：专为 GPU 和加速器优化，提供显著的并行计算能力。
- **内存使用**：使用 GPU 内存，适合处理大型数据集。
- **适用场景**：大规模数值模拟、高性能计算任务、需要 GPU 加速但希望保持 NumPy 风格 API 的场景。

**Section sources**
- [NumpyBackend](file://src/tyxonq/numerics/backends/numpy_backend.py#L7-L162)
- [PyTorchBackend](file://src/tyxonq/numerics/backends/pytorch_backend.py#L12-L256)
- [CuPyNumericBackend](file://src/tyxonq/numerics/backends/cupynumeric_backend.py#L12-L252)

## 全局配置与上下文管理

### 全局后端配置

通过 `set_backend()` 函数可以全局配置数值计算后端。该函数接受后端名称（字符串）或后端实例作为参数。传入字符串时，后端将被延迟解析；传入实例时，将直接使用该实例。

```python
from tyxonq.numerics import set_backend

# 通过名称设置后端
set_backend("pytorch")

# 或通过实例设置后端
from tyxonq.numerics.backends import PyTorchBackend
set_backend(PyTorchBackend())
```

### 数值上下文管理

系统提供了 `use_backend()` 上下文管理器，允许在代码的特定部分临时切换后端，而不会影响全局配置。这在需要对比不同后端性能或在特定计算中使用最优后端时非常有用。

```python
from tyxonq.numerics.context import use_backend

# 在上下文中使用 PyTorch 后端
with use_backend("pytorch"):
    # 此处的计算将使用 PyTorch
    result = some_computation()

# 退出上下文后，恢复之前的后端
```

这种机制确保了数值计算的灵活性和可组合性，允许开发者在不同粒度上控制计算引擎。

**Section sources**
- [set_backend](file://src/tyxonq/numerics/context.py#L17-L29)
- [context.py](file://src/tyxonq/numerics/context.py)