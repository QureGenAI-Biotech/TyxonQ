# 任务提交

<cite>
**本文档中引用的文件**   
- [submit_task.py](file://src/tyxonq/cloud/api.py#L41-L62)
- [tyxonq/driver.py](file://src/tyxonq/devices/hardware/tyxonq/driver.py#L82-L124)
- [ibm/driver.py](file://src/tyxonq/devices/hardware/ibm/driver.py#L23-L32)
- [circuit.py](file://src/tyxonq/core/ir/circuit.py#L539-L550)
- [base.py](file://src/tyxonq/devices/base.py#L162-L280)
- [cloud_api_task.py](file://examples/cloud_api_task.py)
</cite>

## 目录
1. [简介](#简介)
2. [核心组件](#核心组件)
3. [任务提交机制](#任务提交机制)
4. [TyxonQ硬件驱动实现](#tyxonq硬件驱动实现)
5. [任务对象初始化](#任务对象初始化)
6. [错误处理与诊断](#错误处理与诊断)
7. [使用示例](#使用示例)
8. [auto_compile参数与编译流程](#auto_compile参数与编译流程)
9. [IBM驱动现状](#ibm驱动现状)

## 简介
本文档详细描述了TyxonQ量子计算框架中`submit_task`函数的实现机制和使用方式。重点阐述该函数如何通过provider、device、source/circuit、shots等参数配置任务，并委托给`devices.base.run`进行统一执行。文档还详细说明了在TyxonQ硬件驱动中，任务如何被序列化为HTTP POST请求发送至云端API，包括payload结构和认证头处理。同时，文档解释了任务提交后返回的`TyxonQTask`对象的初始化过程，以及在错误情况下如何通过`list_properties`获取设备状态进行诊断。

## 核心组件

本文档涉及的核心组件包括：
- `submit_task`函数：任务提交的统一入口
- `TyxonQTask`类：云端任务的封装对象
- `devices.base.run`：设备层统一执行接口
- `list_properties`：设备状态查询接口

**核心组件**
- [api.py](file://src/tyxonq/cloud/api.py#L41-L62)
- [driver.py](file://src/tyxonq/devices/hardware/tyxonq/driver.py#L82-L124)
- [base.py](file://src/tyxonq/devices/base.py#L162-L280)

## 任务提交机制

`submit_task`函数是任务提交的核心接口，它接受多个参数来配置任务执行环境：

```python
def submit_task(
    *,
    provider: Optional[str] = None,
    device: Optional[str] = None,
    circuit: Optional[Union[Any, Sequence[Any]]] = None,
    source: Optional[Union[str, Sequence[str]]] = None,
    shots: Union[int, Sequence[int]] = 1024,
    token: Optional[str] = None,
    auto_compile: bool = True,
    **opts: Any,
)
```

该函数的主要职责是将任务参数委托给`devices.base.run`进行统一执行，不包含额外的业务逻辑。这种设计实现了任务提交的统一入口，同时将具体的执行逻辑下放到设备层。

当提供`source`参数时，系统会直接提交源代码；当提供`circuit`参数时，系统会先进行编译再提交。`shots`参数用于指定采样次数，默认值为1024。`token`参数用于身份验证，`auto_compile`参数控制是否自动编译。

**任务提交机制**
- [api.py](file://src/tyxonq/cloud/api.py#L41-L62)
- [base.py](file://src/tyxonq/devices/base.py#L162-L280)

## TyxonQ硬件驱动实现

在TyxonQ硬件驱动中，`submit_task`函数负责将任务序列化为HTTP POST请求发送至云端API：

```python
def submit_task(
    device: str,
    token: Optional[str] = None,
    *,
    source: Optional[Union[str, Sequence[str]]] = None,
    shots: Union[int, Sequence[int]] = 1024,
    lang: str = "OPENQASM",
    **kws: Any,
) -> List[TyxonQTask]:
```

该函数首先构建请求URL和认证头，然后构造请求payload。payload结构包含以下字段：
- `device`：目标设备标识
- `shots`：采样次数
- `source`：量子电路源代码
- `version`：API版本号
- `lang`：源代码语言（默认为OPENQASM）

对于批量任务提交，函数会为每个源代码和对应的采样次数创建独立的payload项。请求通过`requests.post`发送，超时时间为30秒。成功响应后，函数会解析返回数据并创建`TyxonQTask`对象。

**TyxonQ硬件驱动实现**
- [driver.py](file://src/tyxonq/devices/hardware/tyxonq/driver.py#L82-L124)

## 任务对象初始化

任务提交成功后，系统会返回一个`TyxonQTask`对象列表。`TyxonQTask`类的初始化过程如下：

```python
def __init__(self, id: str, device: str, status: str, task_info: None, async_result: bool):
    self.id = id
    self.device = device
    self._result = None
    self.task_info = None
    self.async_result = True
    self.status = status
    self.result_metadata = None
```

`TyxonQTask`对象包含以下属性：
- `id`：任务唯一标识符
- `device`：执行任务的设备
- `status`：任务当前状态
- `async_result`：是否为异步结果
- `result_metadata`：结果元数据

对象还提供了`get_result`方法，支持同步和异步获取任务结果。异步模式下，方法会轮询任务状态直到完成或超时。

**任务对象初始化**
- [driver.py](file://src/tyxonq/devices/hardware/tyxonq/driver.py#L12-L41)

## 错误处理与诊断

当任务提交失败时，系统会进行详细的错误处理和诊断：

```python
if data.get('error'):
    # On error, attempt to fetch device properties for diagnostics
    info: Dict[str, Any] = {"error": data, "device": device}
    try:
        props = list_properties(device, token)
        info['device_status'] = props
    except Exception:
        pass
    raise RuntimeError('tyxonq execution error: ' + str(info))
```

错误处理机制首先检查响应数据中的`error`字段。如果存在错误，系统会尝试调用`list_properties`函数获取设备的当前状态信息，以便进行诊断。`list_properties`函数会查询所有可用设备的属性，包括设备ID、状态、连接性等信息。

这些诊断信息会被包含在最终抛出的`RuntimeError`异常中，帮助用户定位问题原因。可能的错误原因包括设备不可用、认证失败、资源不足等。

**错误处理与诊断**
- [driver.py](file://src/tyxonq/devices/hardware/tyxonq/driver.py#L124-L128)
- [driver.py](file://src/tyxonq/devices/hardware/tyxonq/driver.py#L64-L76)

## 使用示例

文档提供了两种主要的使用模式：链式调用和直接提交。

### 链式调用模式

```python
c = tq.Circuit(2)
c.h(0).cx(0, 1).measure_z(0).measure_z(1)
res_chain = c.compile().device(provider="tyxonq", device="homebrew_s2", shots=100).postprocessing().run(wait_async_result=True)
```

在这种模式下，用户首先构建量子电路，然后通过链式调用进行编译、设备配置、后处理设置，最后执行任务。`wait_async_result=True`参数表示等待异步结果完成。

### 直接提交模式

```python
res_legacy = tq.api.submit_task(provider="tyxonq", device="homebrew_s2", source=bell_qasm(), shots=100)
```

在这种模式下，用户直接调用`submit_task`函数，提供设备信息、源代码和采样次数等参数。这种方式适用于已经准备好的量子电路源代码。

**使用示例**
- [cloud_api_task.py](file://examples/cloud_api_task.py)

## auto_compile参数与编译流程

`auto_compile`参数在任务提交过程中扮演重要角色。当该参数为`True`时，系统会自动将高级量子电路编译为目标设备支持的底层指令。

编译流程集成点主要在`Circuit.run`方法中：

```python
def run(
    self,
    *,
    provider: Optional[str] = None,
    device: Optional[str] = None,
    shots: int = 1024,
    wait_async_result: Optional[bool] = False,
    **opts: Any,
) -> Any:
```

当电路没有预编译的源代码时，`run`方法会调用`compile`方法进行自动编译。对于TyxonQ硬件，系统会使用Qiskit编译器将电路转换为QASM2格式。编译过程会考虑目标设备的原生门集和连接性约束，生成优化的量子电路。

`auto_compile`机制确保了高级量子算法可以无缝地在不同硬件平台上执行，而无需用户手动处理编译细节。

**auto_compile参数与编译流程**
- [circuit.py](file://src/tyxonq/core/ir/circuit.py#L404-L515)
- [circuit.py](file://src/tyxonq/core/ir/circuit.py#L373-L402)

## IBM驱动现状

目前，IBM驱动的提交功能尚未实现：

```python
def submit_task(
    device: str,
    token: Optional[str] = None,
    *,
    circuit: Optional[Union[Any, Sequence[Any]]] = None,
    source: Optional[Union[str, Sequence[str]]] = None,
    shots: Union[int, Sequence[int]] = 1024,
    **opts: Any,
) -> List[Any]:
    raise NotImplementedError("IBM driver is a skeleton; submission not wired yet")
```

该实现只是一个骨架，调用时会抛出`NotImplementedError`异常。这表明IBM量子设备的集成仍在进行中，尚未完成任务提交功能的开发。用户在尝试使用IBM设备时需要选择其他可用的硬件提供商或使用本地模拟器。

**IBM驱动现状**
- [driver.py](file://src/tyxonq/devices/hardware/ibm/driver.py#L23-L32)